import type { ValidationStep } from "./rules/base-rule.js";

export interface SchemaRuleNames {
	'field::require'?: boolean;
	require?: boolean;
	'field::requireIf'?: `${string}=${string}`;
	requireIf?: `${string}=${string}`;
	'field::requireUnless'?: `${string}=${string}`;
	requireUnless?: `${string}=${string}`;
	'field::requireWith'?: string[];
	requireWith?: string[];
	'field::requireWithout'?: string[];
	requireWithout?: string[];
	'field::match'?: string;
	match?: string;
	'field::atLeastOne'?: string[];
	atLeastOne?: string[];
	'field::onlyOne'?: string[];
	onlyOne?: string[];
	'field::allOrNone'?: string[];
	allOrNone?: string[];
	'number::valid'?: boolean;
	number?: boolean;
	numeric?: boolean;
	'number::positive'?: boolean;
	positiveNumber?: boolean;
	'number::negative'?: boolean;
	negativeNumber?: boolean;
	'number::min'?: number;
	minNum?: number;
	'number::max'?: number;
	maxNum?: number;
	'number::between'?: [number, number];
	numBetween?: [number, number];
	'number::multipleOf'?: number;
	numMultipleOf?: number;
	'integer::valid'?: boolean;
	integer?: boolean;
	int?: boolean;
	'integer::positive'?: boolean;
	positiveInt?: boolean;
	'integer::negative'?: boolean;
	negativeInt?: boolean;
	'integer::min'?: number;
	minInt?: number;
	'integer::max'?: number;
	maxInt?: number;
	'integer::between'?: [number, number];
	intBetween?: [number, number];
	'integer::even'?: boolean;
	evenInt?: boolean;
	'integer::odd'?: boolean;
	oddInt?: boolean;
	'integer::equals'?: number;
	intEquals?: number;
	'integer::notEquals'?: number;
	intNotEquals?: number;
	'integer::gt'?: number;
	gt?: number;
	'integer::gte'?: number;
	gte?: number;
	'integer::lt'?: number;
	lt?: number;
	'integer::lte'?: number;
	lte?: number;
	'float::valid'?: boolean;
	float?: boolean;
	double?: boolean;
	'float::positive'?: boolean;
	positiveFloat?: boolean;
	'float::negative'?: boolean;
	negativeFloat?: boolean;
	'float::min'?: number;
	minFloat?: number;
	'float::max'?: number;
	maxFloat?: number;
	'float::between'?: [number, number];
	floatBetween?: [number, number];
	'float::equals'?: number;
	floatEquals?: number;
	'float::notEquals'?: number;
	floatNotEquals?: number;
	'float::gt'?: number;
	floatGt?: number;
	'float::gte'?: number;
	floatGte?: number;
	'float::lt'?: number;
	floatLt?: number;
	'float::lte'?: number;
	floatLte?: number;
	'float::longitude'?: boolean;
	longitude?: boolean;
	'float::latitude'?: boolean;
	latitude?: boolean;
	'string::valid'?: boolean;
	string?: boolean;
	'string::minLength'?: number;
	minLength?: number;
	'string::maxLength'?: number;
	maxLength?: number;
	'string::length'?: number;
	length?: number;
	'string::alpha'?: boolean;
	alpha?: boolean;
	'string::alphaspace'?: boolean;
	alphaspace?: boolean;
	'string::alphanum'?: boolean;
	alphanum?: boolean;
	'string::alphanumspace'?: boolean;
	alphanumspace?: boolean;
	'string::in'?: string[];
	inList?: string[];
	'string::notIn'?: string[];
	notInList?: string[];
	'string::equals'?: string;
	strEquals?: string;
	'string::notEquals'?: string;
	strNotEquals?: string;
	'string::contains'?: string;
	strContains?: string;
	'string::notContains'?: string;
	strNotContains?: string;
	'string::startsWith'?: string;
	strStartsWith?: string;
	'string::notStartsWith'?: string;
	strNotStartsWith?: string;
	'string::endsWith'?: string;
	strEndsWith?: string;
	'string::notEndsWith'?: string;
	strNotEndsWith?: string;
	'string::lowercase'?: boolean;
	strLowercase?: boolean;
	'string::uppercase'?: boolean;
	strUppercase?: boolean;
	'string::strongPassword'?: boolean;
	strongPassword?: boolean;
	'string::email'?: boolean;
	email?: boolean;
	'string::mobile'?: boolean;
	mobile?: boolean;
	'string::pincode'?: boolean;
	pincode?: boolean;
	'string::pan'?: boolean;
	pan?: boolean;
	'string::ifsc'?: boolean;
	ifsc?: boolean;
	'string::slug'?: boolean;
	slug?: boolean;
	'string::url'?: boolean;
	url?: boolean;
	'string::urlSecure'?: boolean;
	urlSecure?: boolean;
	'string::domain'?: boolean;
	domain?: boolean;
	'string::ip'?: boolean;
	ip?: boolean;
	'string::ipv4'?: boolean;
	ipv4?: boolean;
	'string::ipv6'?: boolean;
	ipv6?: boolean;
	'string::uuid'?: boolean;
	uuid?: boolean;
	'string::noSpace'?: boolean;
	noSpace?: boolean;
	'string::noEmoji'?: boolean;
	noEmoji?: boolean;
	'string::asciiOnly'?: boolean;
	asciiOnly?: boolean;
	'string::json'?: boolean;
	jsonString?: boolean;
	'string::wordCount'?: [number, number];
	wordCount?: [number, number];
	'string::latlong'?: boolean;
	latlong?: boolean;
	'boolean::valid'?: boolean;
	boolean?: boolean;
	bool?: boolean;
	'date::valid'?: boolean;
	date?: boolean;
	'date::before'?: string;
	dateBefore?: string;
	'date::after'?: string;
	dateAfter?: string;
	'date::equals'?: string;
	dateEquals?: string;
	'date::between'?: [string, string];
	dateBetween?: [string, string];
	'date::today'?: boolean;
	dateToday?: boolean;
	'date::past'?: boolean;
	datePast?: boolean;
	'date::future'?: boolean;
	dateFuture?: boolean;
	'time::valid'?: boolean;
	time?: boolean;
	'time::before'?: string;
	timeBefore?: string;
	'time::after'?: string;
	timeAfter?: string;
	'time::equals'?: string;
	timeEquals?: string;
	'time::between'?: [string, string];
	timeBetween?: [string, string];
	'datetime::valid'?: boolean;
	datetime?: boolean;
	'datetime::before'?: string;
	datetimeBefore?: string;
	'datetime::after'?: string;
	datetimeAfter?: string;
	'datetime::equals'?: string;
	datetimeEquals?: string;
	'datetime::between'?: [string, string];
	datetimeBetween?: [string, string];
	'datetime::past'?: boolean;
	datetimePast?: boolean;
	'datetime::future'?: boolean;
	datetimeFuture?: boolean;
	'file::valid'?: boolean;
	file?: boolean;
	'file::minFiles'?: number;
	minFiles?: number;
	'file::maxFiles'?: number;
	maxFiles?: number;
	'file::minSize'?: string;
	minFileSize?: string;
	'file::maxSize'?: string;
	maxFileSize?: string;
	'file::accepts'?: string[];
	fileAccepts?: string[];
	'file::noAccepts'?: string[];
	fileNotAccepts?: string[];
	'file::imageOnly'?: boolean;
	fileImageOnly?: boolean;
	'file::videoOnly'?: boolean;
	fileVideoOnly?: boolean;
	'file::audioOnly'?: boolean;
	fileAudioOnly?: boolean;
	'array::valid'?: boolean;
	array?: boolean;
	'array::notEmpty'?: boolean;
	notEmptyArray?: boolean;
	'array::unique'?: boolean;
	uniqueArray?: boolean;
	'array::minItems'?: number;
	minItems?: number;
	arrayMinLength?: number;
	'array::maxItems'?: number;
	maxItems?: number;
	arrayMaxLength?: number;
	'array::includes'?: any;
	arrayIncludes?: any;
	arrayContains?: any;
	'array::excludes'?: any;
	arrayExcludes?: any;
	arrayNotContains?: any;
	'array::latLong'?: boolean;
	latLongArray?: boolean;
	'array::longLat'?: boolean;
	longLatArray?: boolean;
	'array::of'?: string;
	arrayOf?: string;
	'array::notOf'?: string;
	arrayNotOf?: string;
	trim?: boolean;
	preTrim?: boolean;
	'case::camel'?: boolean;
	toCamelcase?: boolean;
	'case::kebab'?: boolean;
	toKebabcase?: boolean;
	'case::lower'?: boolean;
	toLowercase?: boolean;
	'case::pascal'?: boolean;
	toPascalcase?: boolean;
	'case::sentence'?: boolean;
	toSentencecase?: boolean;
	'case::snake'?: boolean;
	toSnakecase?: boolean;
	'case::title'?: boolean;
	toTitlecase?: boolean;
	'case::upper'?: boolean;
	toUppercase?: boolean;
	'case::ucFirst'?: boolean;
	toUcFirst?: boolean;
	'case::capitalize'?: boolean;
	toCapitalize?: boolean;
	'preCase::camel'?: boolean;
	preToCamelcase?: boolean;
	'preCase::kebab'?: boolean;
	preToKebabcase?: boolean;
	'preCase::lower'?: boolean;
	preToLowercase?: boolean;
	'preCase::pascal'?: boolean;
	preToPascalcase?: boolean;
	'preCase::sentence'?: boolean;
	preToSentencecase?: boolean;
	'preCase::snake'?: boolean;
	preToSnakecase?: boolean;
	'preCase::title'?: boolean;
	preToTitlecase?: boolean;
	'preCase::upper'?: boolean;
	preToUppercase?: boolean;
	'preCase::ucFirst'?: boolean;
	preToUcFirst?: boolean;
	'preCase::capitalize'?: boolean;
	preToCapitalize?: boolean;
	'cast::integer'?: boolean;
	toInteger?: boolean;
	'cast::float'?: boolean;
	toFloat?: boolean;
	'cast::boolean'?: boolean;
	toBoolean?: boolean;
	'cast::toJson'?: boolean;
	toJson?: boolean;
	'cast::fromJson'?: boolean;
	fromJson?: boolean;
	'preCast::integer'?: boolean;
	preToInteger?: boolean;
	'preCast::float'?: boolean;
	preToFloat?: boolean;
	'preCast::boolean'?: boolean;
	preToBoolean?: boolean;
	'preCast::toJson'?: boolean;
	preToJson?: boolean;
	'preCast::fromJson'?: boolean;
	preFromJson?: boolean;
	'math::ceil'?: boolean;
	ceil?: boolean;
	roundUp?: boolean;
	'math::floor'?: boolean;
	floor?: boolean;
	roundDown?: boolean;
	'math::round'?: boolean;
	round?: boolean;
	'math::toFixed'?: number;
	toFixed?: number;
	'object::valid'?: boolean;
	object?: boolean;
	'object::notEmpty'?: boolean;
	notEmptyObject?: boolean;
	'object::includes'?: string;
	objectIncludes?: string;
	objectContains?: string;
	'object::excludes'?: string;
	objectExcludes?: string;
	objectNotContains?: string;
	'object::hasKeys'?: string[];
	objectHasKeys?: string[];
	'object::hasAnyKey'?: string[];
	objectHasAnyKey?: string[];
	'object::onlyKeys'?: string[];
	objectOnlyKeys?: string[];
	'object::minKeys'?: number;
	objectMinKeys?: number;
	'object::maxKeys'?: number;
	objectMaxKeys?: number;
	'object::exactKeys'?: number;
	objectExactKeys?: number;
	'object::allValuesType'?: string;
	objectValuesType?: string;
	'object::noNullValues'?: boolean;
	objectNoNull?: boolean;
	'object::noUndefinedValues'?: boolean;
	objectNoUndefined?: boolean;
	'object::deepIncludes'?: string;
	objectDeepIncludes?: string;
	'object::isPlain'?: boolean;
	plainObject?: boolean;
};

export type RuleName<K = keyof SchemaRuleNames> = K;

export type SchemaField = SchemaRuleNames & {
	optional?: boolean;
	default?: any;
	custom?: ValidationStep;
	schema?: Record<string, SchemaField>;
	messages?: {
		[key in RuleName]?: string;
	};
}